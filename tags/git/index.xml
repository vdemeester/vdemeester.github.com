<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Git on Vincent Demeester</title>
    <link>http://vincent.demeester.fr/tags/git/</link>
    <description>Recent content in Git on Vincent Demeester</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>fr-fr</language>
    <lastBuildDate>Fri, 31 Jul 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://vincent.demeester.fr/tags/git/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Gestion de configuration : introduction</title>
      <link>http://vincent.demeester.fr/posts/2015-07-31-config-managment-intro/</link>
      <pubDate>Fri, 31 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://vincent.demeester.fr/posts/2015-07-31-config-managment-intro/</guid>
      <description>&lt;p&gt;
Cela doit faire au moins 2 ans que je souhaite partager la façon dont
je gère mes configurations (en anglais &lt;i&gt;dotfiles&lt;/i&gt;). Comme j&#39;ai
longtemps repoussé l&#39;échéance, probablement de peur d&#39;avoir un roman à
écrire, je vais en faire une série de petits billets de blog dont
celui-ci est l&#39;introduction. Nous y aborderons donc mon besoin, et mes
choix.
&lt;/p&gt;

&lt;div id=&#34;outline-container-sec-1&#34; class=&#34;outline-2&#34;&gt;
&lt;h2 id=&#34;sec-1&#34;&gt;Besoin(s)&lt;/h2&gt;
&lt;div class=&#34;outline-text-2&#34; id=&#34;text-1&#34;&gt;
&lt;p&gt;
En bon &lt;b&gt;geek&lt;/b&gt; que je suis, je suis fan des &lt;i&gt;dotfiles&lt;/i&gt;. Les &lt;i&gt;dotfiles&lt;/i&gt;
— fichiers de configurations — sont de petits fichiers, habituellement
dans notre dossier personnel (votre &lt;i&gt;$HOME&lt;/i&gt;), qui nous permettent de
paramétrer et personnaliser nos outils de tous les jours. C&#39;est
principalement vrai pour des outils en ligne de commande — et ça tombe
bien, j&#39;adore — mais pas uniquement limité à ces derniers.
&lt;/p&gt;

&lt;p&gt;
Je vais faire un très petit aparté sur le pourquoi de cette
personnalisation :
&lt;/p&gt;

&lt;ul class=&#34;org-ul&#34;&gt;
&lt;li&gt;C&#39;est &lt;b&gt;fun&lt;/b&gt; à faire et c&#39;est relativement important de mon point de vue.
&lt;/li&gt;
&lt;li&gt;C&#39;est &lt;b&gt;éducatif&lt;/b&gt; ou formateur ; on lit les documentations de nos
outils, leurs fonctionnalités un peu cachées. On va souvent découvrir
un peu la philosophie dans laquelle l&#39;outil a été créé. C&#39;est en
mettant les &lt;i&gt;mains dans le cambouis&lt;/i&gt; et en &lt;i&gt;foutant un gros bordel&lt;/i&gt;
que j&#39;ai le plus appris (ça va du &lt;i&gt;langage&lt;/i&gt; shell et d&#39;autres
langages de scripts, de POSIX, au noyau linux ou encore au LISP avec
GNU/Emacs).
&lt;/li&gt;
&lt;li&gt;Cela fait &lt;b&gt;gagner du temps&lt;/b&gt; et de manière non négligeable. Je suis
né &lt;span class=&#34;underline&#34;&gt;courageux mais terriblement fainéant&lt;/span&gt; (et oui c&#39;est possible
&lt;code&gt;:-P&lt;/code&gt;), j&#39;aime pas trop me répéter quand ça devient un peu compliqué
/ chiant (e.g. &lt;code&gt;docker run monimage args&lt;/code&gt; ça va, &lt;code&gt;docker run&lt;/code&gt; avec
&lt;code&gt;-v /tmp:/tmp -v /var/run/docker.socket:/var/run/docker.socket […]&lt;/code&gt;
et &lt;code&gt;run monimage arg1 arg2 arg3 […]&lt;/code&gt; moins déjà).
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Mais revenons à nos moutons et faisons une petite liste de mes besoins, un
peu en vrac :
&lt;/p&gt;

&lt;ul class=&#34;org-ul&#34;&gt;
&lt;li&gt;J&#39;ai plusieurs ordinateurs (laptop/desktop/serveurs) et je souhaite
avoir mes configurations &lt;b&gt;synchronisées&lt;/b&gt; entre ceux-ci — et ce de
manière simple, c&#39;est à dire &lt;i&gt;une commande à exécuter&lt;/i&gt;.
&lt;/li&gt;
&lt;li&gt;C&#39;est lié au point précédent mais, je ne &lt;i&gt;peux pas vivre&lt;/i&gt; sans
outil de gestion de version, comme &lt;b&gt;git&lt;/b&gt;. Il me faut donc un outil
ou ensemble d&#39;outil qui sache utiliser des outils de gestion de
version &lt;i&gt;du marché&lt;/i&gt;.


&lt;div class=&#34;figure&#34;&gt;
&lt;p&gt;&lt;img src=&#34;./img/git-all-the-thing.jpg&#34; alt=&#34;git-all-the-thing.jpg&#34; /&gt;
&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;

&lt;li&gt;En fonction de mes ordinateurs, mes besoins de configuration
changent. Il me faut donc un outil &lt;b&gt;flexible&lt;/b&gt; qui me permette de dire
par exemple : sur ce PC j&#39;ai un serveur &lt;code&gt;Xorg&lt;/code&gt; donc j&#39;ai besoin de
mes configuration xorg, de celle de mon &lt;i&gt;window manager&lt;/i&gt;, etc. — et
inversement sur ce serveur j&#39;ai besoin de python et haskell mais pas
de xorg..
&lt;/li&gt;
&lt;li&gt;Je ne souhaites pas avoir à faire des liens symboliques, ou de
scripts d&#39;installation. Je trouves que ça rends les choses plus
compliquées. Du coup il faut que je puisse avoir &lt;b&gt;plusieurs &lt;i&gt;dépôts
de configuration&lt;/i&gt;&lt;/b&gt; (repository) qui pointent au même endroit, sans
que ce soit le bordel.
&lt;/li&gt;
&lt;li&gt;Le &lt;b&gt;partage&lt;/b&gt; est important pour moi. Il en découle deux choses :
&lt;ol class=&#34;org-ol&#34;&gt;
&lt;li&gt;Il faut que je puisse documenter un peu mon repository, avec un
bon vieux &lt;code&gt;README&lt;/code&gt; ; sans que chaque &lt;code&gt;README&lt;/code&gt; se marche dessus.
&lt;/li&gt;
&lt;li&gt;Il y a quelques &lt;b&gt;informations&lt;/b&gt; qui sont &lt;b&gt;personnelles&lt;/b&gt;, comme par
exemple les clés ssh. Il me faut donc être capable d&#39;avoir des
&lt;i&gt;dépôts publiques&lt;/i&gt; et des &lt;i&gt;dépôts privés&lt;/i&gt;. C&#39;est grandement facilité
par l&#39;aspect &lt;i&gt;flexibilité&lt;/i&gt; &lt;code&gt;:-)&lt;/code&gt;.
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Un bonus que je souhaite, est de pouvoir disposer de &lt;b&gt;hooks&lt;/b&gt;, un peu
à la manière de git (voir &lt;a href=&#34;https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks&#34;&gt;ici&lt;/a&gt;). L&#39;idée est de pouvoir &lt;b&gt;générer&lt;/b&gt; un
fichier de configuration à partir d&#39;un ensemble de fichiers qui
viendraient de différents dépôts. Le meilleur exemple que je peux
donner c&#39;est &lt;code&gt;~/.ssh/config&lt;/code&gt; dans lequel je vais y mettre des bouts
publiques que je souhaites partager (comme le &lt;code&gt;Host *&lt;/code&gt; avec des
trucs cool comme &lt;code&gt;ControlPersist&lt;/code&gt;, on en parlera plus tard) et des
bouts privés (mes hosts privés, avec mes configurations de
&lt;i&gt;rebonds&lt;/i&gt;, etc..).
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Cette liste a mis un certain temps à se former dans ma tête, mais une
fois qu&#39;elle était formée, j&#39;ai pu assez facilement faire des choix.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&#34;outline-container-sec-2&#34; class=&#34;outline-2&#34;&gt;
&lt;h2 id=&#34;sec-2&#34;&gt;Choix&lt;/h2&gt;
&lt;div class=&#34;outline-text-2&#34; id=&#34;text-2&#34;&gt;
&lt;p&gt;
Deux outils et un peu d&#39;organisation permettent de répondre à mes
besoins. Les deux outils sont &lt;code&gt;vcsh&lt;/code&gt; et &lt;code&gt;myrepos&lt;/code&gt; (anciennement appelé
&lt;code&gt;mr&lt;/code&gt;), fait par respectivement Richard Hartmann et Joey Hess (tout
deux assez impliqué dans la communauté Debian).
&lt;/p&gt;
&lt;/div&gt;

&lt;div id=&#34;outline-container-sec-2-1&#34; class=&#34;outline-3&#34;&gt;
&lt;h3 id=&#34;sec-2-1&#34;&gt;vcsh&lt;/h3&gt;
&lt;div class=&#34;outline-text-3&#34; id=&#34;text-2-1&#34;&gt;
&lt;p&gt;
En un mot, &lt;a href=&#34;https://github.com/RichiH/vcsh&#34;&gt;vcsh&lt;/a&gt; permet de maintenir plusieurs &lt;i&gt;repository&lt;/i&gt; &lt;a href=&#34;http://git-scm.com/&#34;&gt;git&lt;/a&gt; dans
un seul dossier. Par défaut tous les &lt;i&gt;repository&lt;/i&gt; git maintenus par
&lt;code&gt;vcsh&lt;/code&gt; pointent vers le dossier &lt;code&gt;$HOME&lt;/code&gt;, mais il est possible
d&#39;utiliser un autre dossier.
&lt;/p&gt;

&lt;p&gt;
L&#39;idée est de pouvoir disposer de plusieurs repository par &lt;i&gt;famille
d&#39;application&lt;/i&gt;, par exemple &lt;code&gt;vim&lt;/code&gt;, &lt;code&gt;ssh&lt;/code&gt;, &lt;code&gt;emacs&lt;/code&gt;, &lt;code&gt;zsh&lt;/code&gt;, etc. Cela
permet ainsi d&#39;avoir différents ensemble de configurations sur
différentes machines et pour différents utilisateurs. Cela apporte
une très grande flexibilité et facilite le partage de configuration
(au sein d&#39;une entreprise ou d&#39;un projet par exemple) tout en
laissant la place à la définition de configuration(s)
personnalisé(s).
&lt;/p&gt;

&lt;p&gt;
En bonus, &lt;code&gt;vcsh&lt;/code&gt; supporte un système de hook, permettant d&#39;exécuter
des commandes à différents moments du &lt;i&gt;workflow&lt;/i&gt; — c&#39;est la seule
partie qui manquant à &lt;code&gt;vcsh&lt;/code&gt; de mon point de vue alors j&#39;y ai
apporté ma petit pierre.
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;vcsh&lt;/code&gt; est la clé de voûte de ma gestion de configuration. Sans le
travail formidable de &lt;a href=&#34;http://richardhartmann.de/&#34;&gt;Richard Hartmann&lt;/a&gt;, je ne sais pas comment je
ferais..
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&#34;outline-container-sec-2-2&#34; class=&#34;outline-3&#34;&gt;
&lt;h3 id=&#34;sec-2-2&#34;&gt;myrepos&lt;/h3&gt;
&lt;div class=&#34;outline-text-3&#34; id=&#34;text-2-2&#34;&gt;
&lt;p&gt;
En un mot, &lt;a href=&#34;https://myrepos.branchable.com/&#34;&gt;myrepos&lt;/a&gt; est un outil permettant de &lt;i&gt;gérer&lt;/i&gt; plusieurs
repository (git, subversion, mercurial, …) avec une seule
commande : &lt;code&gt;mr&lt;/code&gt;. C&#39;est simple et efficace :
&lt;/p&gt;

&lt;ul class=&#34;org-ul&#34;&gt;
&lt;li&gt;&lt;code&gt;mr u&lt;/code&gt; (ou &lt;code&gt;mr update&lt;/code&gt;) pour récupérer les dernières modifications (&lt;code&gt;git pull&lt;/code&gt;,
&lt;code&gt;svn up&lt;/code&gt;, …).
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mr -d $HOME/.config u&lt;/code&gt; pour récupérer les dernières modifications
des repository qui sont dans &lt;code&gt;$HOME/.config&lt;/code&gt;.
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mr -j 6 u&lt;/code&gt; pour paralléliser la récupération (ici 6 jobs en parallèle).
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mr p&lt;/code&gt; pour pousser des modifications (&lt;code&gt;git push&lt;/code&gt;, …).
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mr run&lt;/code&gt; pour lancer un commande (j&#39;utilise ça tous les jours).
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Il est également possible de personnaliser les commandes à lancer lors
d&#39;un &lt;i&gt;update&lt;/i&gt; ou autre (toutes les commandes), et même en définir des
nouvelles. Cela se présente comme suit :
&lt;/p&gt;


&lt;div class=&#34;org-src-container&#34;&gt;

&lt;pre class=&#34;src src-conf&#34;&gt;[&lt;span style=&#34;color: #FFCC80;&#34;&gt;foo&lt;/span&gt;]
&lt;span style=&#34;color: #80CBC4;&#34;&gt;checkout&lt;/span&gt; = git@github.com:joeyh/foo.git
&lt;span style=&#34;color: #80CBC4;&#34;&gt;update&lt;/span&gt; = git pull --rebase

[&lt;span style=&#34;color: #FFCC80;&#34;&gt;bar&lt;/span&gt;]
&lt;span style=&#34;color: #757575;&#34;&gt;# &lt;/span&gt;&lt;span style=&#34;color: #757575;&#34;&gt;This repository has an upstream, which I&#39;ve forked;&lt;/span&gt;
&lt;span style=&#34;color: #757575;&#34;&gt;# &lt;/span&gt;&lt;span style=&#34;color: #757575;&#34;&gt;set up a remote on checkout.&lt;/span&gt;
&lt;span style=&#34;color: #80CBC4;&#34;&gt;checkout&lt;/span&gt; =
    git clone git@github.com:joeyh/bar.git
    cd bar
    git remote add upstream git@github.com:barbar/bar.git
&lt;span style=&#34;color: #757575;&#34;&gt;# &lt;/span&gt;&lt;span style=&#34;color: #757575;&#34;&gt;make `mr zap` integrate from upstream&lt;/span&gt;
&lt;span style=&#34;color: #80CBC4;&#34;&gt;zap&lt;/span&gt; =
    git pull upstream
    git merge upstream/master
    git push origin master

[&lt;span style=&#34;color: #FFCC80;&#34;&gt;mystuff&lt;/span&gt;]
&lt;span style=&#34;color: #80CBC4;&#34;&gt;checkout&lt;/span&gt; = git@github.com:joeyh/foo.git
&lt;span style=&#34;color: #757575;&#34;&gt;# &lt;/span&gt;&lt;span style=&#34;color: #757575;&#34;&gt;Skip if the current user is not joey&lt;/span&gt;
&lt;span style=&#34;color: #80CBC4;&#34;&gt;skip&lt;/span&gt; = test `whoami` != joey

[&lt;span style=&#34;color: #FFCC80;&#34;&gt;DEFAULT&lt;/span&gt;]
&lt;span style=&#34;color: #757575;&#34;&gt;# &lt;/span&gt;&lt;span style=&#34;color: #757575;&#34;&gt;Teach mr how to `mr gc` in git repos.&lt;/span&gt;
&lt;span style=&#34;color: #80CBC4;&#34;&gt;git_gc&lt;/span&gt; = git gc &lt;span style=&#34;color: #C5E1A5;&#34;&gt;&#34;$@&#34;&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;
Une autre fonctionnalité qui m&#39;est totalement indispensable est ce
qu&#39;on appel les &lt;code&gt;fixup(s)&lt;/code&gt;. Il est en effet possible d&#39;exécuter une ou
plusieurs commandes (shell) après un &lt;code&gt;update&lt;/code&gt; (ou via la commande
&lt;code&gt;fixup&lt;/code&gt;). C&#39;est grâce à ce système la que je génère mes fichiers de
configuration en provenance de plusieurs repository (comme
&lt;code&gt;$HOME/.ssh/config&lt;/code&gt; ou encore &lt;code&gt;$HOME/.gitconfig&lt;/code&gt;).
&lt;/p&gt;

&lt;p&gt;
&lt;code&gt;myrepos&lt;/code&gt; est l&#39;exemple de l&#39;outil simple et efficace qui fait une
chose et le fait très bien, et dont je n&#39;arrive pas à me passer
&lt;code&gt;:-D&lt;/code&gt;. Je l&#39;utilise également dans plein d&#39;autres cas, comme par
exemple pour mettre à jour mes &lt;i&gt;forks&lt;/i&gt; de projets open-source.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id=&#34;outline-container-sec-3&#34; class=&#34;outline-2&#34;&gt;
&lt;h2 id=&#34;sec-3&#34;&gt;Conclusion&lt;/h2&gt;
&lt;div class=&#34;outline-text-2&#34; id=&#34;text-3&#34;&gt;
&lt;p&gt;
Et voilà, c&#39;est tout pour cette introduction &lt;code&gt;;-)&lt;/code&gt;. La prochaine
partie se penchera sur la &lt;b&gt;structure&lt;/b&gt; que j&#39;utilise ainsi que le
repository principal qui est &lt;a href=&#34;https://github.com/vdemeester/vcsh-home&#34;&gt;&lt;b&gt;vcsh-home&lt;/b&gt;&lt;/a&gt;. Dans les parties suivantes
on parlera des autres repository et donc des configurations
spécifiques pour les différents outils (comme &lt;a href=&#34;https://github.com/vdemeester/sh-config&#34;&gt;sh-config&lt;/a&gt;,
&lt;a href=&#34;https://github.com/vdemeester/emacs-config&#34;&gt;emacs-config&lt;/a&gt; ou encore &lt;a href=&#34;https://github.com/vdemeester/go-config&#34;&gt;go-config&lt;/a&gt;). On parlera aussi probablement de
&lt;code&gt;git-annex&lt;/code&gt; dans le futur.
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Maven Release Gitflow</title>
      <link>http://vincent.demeester.fr/posts/2012-07-23-maven-release-gitflow/</link>
      <pubDate>Mon, 23 Jul 2012 00:00:00 +0000</pubDate>
      
      <guid>http://vincent.demeester.fr/posts/2012-07-23-maven-release-gitflow/</guid>
      <description>

&lt;p&gt;I like a lot the &lt;a href=&#34;http://nvie.com/posts/a-successful-git-branching-model/&#34;&gt;gitflow&lt;/a&gt; way of managing project.
When working on maven project, there is few great plugins that helps to get
the work done. One of them is &lt;a href=&#34;http://maven.apache.org/plugins/maven-release-plugin&#34;&gt;maven-release-plugin&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Inspired on this &lt;a href=&#34;https://gist.github.com/1043970&#34;&gt;gist&lt;/a&gt;, I&amp;rsquo;ve come with
a cool way of doing things (let say we want to release a 0.1 version of an
artifact) :&lt;/p&gt;

&lt;h1 id=&#34;prepare-the-pom-xml&#34;&gt;Prepare the pom.xml.&lt;/h1&gt;

&lt;p&gt;It needs &lt;code&gt;&amp;lt;scm&amp;gt;&lt;/code&gt; entries, &lt;code&gt;&amp;lt;distributionManagement&amp;gt;&lt;/code&gt; entries
(to know where to deploy the release artifact) and few options for the
maven-release-plugin :&lt;/p&gt;


&lt;project&gt;

    &lt;!-- […] --&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;!-- […] --&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-release-plugin&lt;/artifactId&gt;
                &lt;version&gt;2.3.2&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;tagNameFormat&gt;v@{project.version}&lt;/tagNameFormat&gt;
                    &lt;pushChanges&gt;false&lt;/pushChanges&gt;
                    &lt;localCheckout&gt;true&lt;/localCheckout&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
            &lt;!-- […] --&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
    &lt;!-- […] --&gt;

&lt;/project&gt;


&lt;p&gt;Few explanation here :&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;tagNameFormat&lt;/code&gt; is here to change the default tag name (which is &lt;code&gt;${project.artifactId}-${project.version}&lt;/code&gt;) to a better one.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pushChanges&lt;/code&gt; set to &lt;code&gt;false&lt;/code&gt; tells  maven-release-plugin not to push
changes (this will become useful)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;localCheckout&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; tells maven-release-plugin to clone from
local repository (not distant). This is especially useful here because we
didn&amp;rsquo;t push anything (so not setting this option would result in a failure).&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;the-real-stuff&#34;&gt;The real stuff&lt;/h1&gt;

&lt;p&gt;First create a release branch from develop.&lt;/p&gt;


$ git checkout -b release/v0.1 develop


&lt;p&gt;Then run the maven release stuff.&lt;/p&gt;


$ mvn release:prepare               # change the pom, commit and tag version, and
                                    # re-change pom (by incrementing SNAPSHOT version)
$ mvn release:perform               # get the tagged version, compile and deploy


&lt;p&gt;And the real fun begins.&lt;/p&gt;


$ git checkout develop              # get back to the develop branch
$ git merge --no-ff release/v0.1    # merge the version back into develop
$ git checkout master               # go to the master branch
$ git merge --no-ff release/v0.1~1  # merge the version back into master but
                                    # the tagged version instead of the release/v0.1 HEAD
$ git branch -D release/v0.1        # Removing the release branch
$ git push --all &amp;&amp; git push --tags # Finally push everything


&lt;p&gt;The real magic here is the &lt;code&gt;git merge --no-ff release/v0.1~1&lt;/code&gt; which will
merge into master the commit before the HEAD of the branch &lt;code&gt;release/v0.1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The next step would be to create a helper script that automates this and
verify that the &lt;code&gt;pom.xml&lt;/code&gt; has the right configuration options.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Edit 17:58&lt;/strong&gt; : You can take a look &lt;a href=&#34;https://github.com/vdemeester/java-config/blob/master/bin/mvn-release-flow&#34;&gt;here&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gitolite quick and dirty mirror</title>
      <link>http://vincent.demeester.fr/posts/2012-05-08-gitolite-quick-and-dirty-mirror/</link>
      <pubDate>Tue, 08 May 2012 00:00:00 +0000</pubDate>
      
      <guid>http://vincent.demeester.fr/posts/2012-05-08-gitolite-quick-and-dirty-mirror/</guid>
      <description>

&lt;p&gt;I&amp;rsquo;m running a gitolite &lt;em&gt;instance&lt;/em&gt; on my personal server to manage my repositories
(personnal, private or public) ; and I am quickly going to share with you how I
setup a &lt;em&gt;quick and dirty&lt;/em&gt; mirror feature.&lt;/p&gt;

&lt;p&gt;First, I am using &lt;strong&gt;gitolite 3&lt;/strong&gt;. The mirroring we are going to setup is not the
&lt;em&gt;supported&lt;/em&gt; &lt;a href=&#34;http://sitaramc.github.com/gitolite/mirroring.html&#34;&gt;mirroring &lt;strong&gt;built-in&lt;/strong&gt;&lt;/a&gt;.
We are going to implement a simplier way to set mirror thing :&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Write a custom gitolite command ; the idea is to be able to write &lt;code&gt;git-config&lt;/code&gt;
stuff.&lt;/li&gt;
&lt;li&gt;Write a hook that take a specific &lt;code&gt;git-config&lt;/code&gt; (let say &lt;code&gt;mirror.url&lt;/code&gt;) and do
a simple mirroring.&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;gitolite-commands&#34;&gt;Gitolite commands&lt;/h1&gt;

&lt;p&gt;Gitolite 3 has been rewritten to be more flexible : &lt;a href=&#34;http://sitaramc.github.com/gitolite/g3why.html&#34;&gt;Why a completely new version&lt;/a&gt;.
The rewrite made it really easy to extend gitolite. &lt;del&gt;I&amp;rsquo;ve fork &lt;a href=&#34;https://github.com/vdemeester/gitolite&#34;&gt;gitolite&lt;/a&gt; on github&lt;/del&gt;
I&amp;rsquo;ve created a &lt;a href=&#34;http://github.com/vdemeester/vdemeester-gitolite-local-code&#34;&gt;repository git&lt;/a&gt;
to easily add commands to my gitolite instance via &lt;em&gt;local code&lt;/em&gt;. The gitolite command I wrote is
a quick and dirty script in shell to add &lt;code&gt;git config&lt;/code&gt;. The source should speek
for itself ; It &lt;em&gt;should&lt;/em&gt; include some way to check if the given config is not
already present in the &lt;code&gt;gitolite-admin&lt;/code&gt; configuration file — and so might be
rewritten in &lt;code&gt;Perl&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The command is &lt;code&gt;write-git-config&lt;/code&gt; because a &lt;code&gt;git-config&lt;/code&gt; command already exists
in the built-in commands.&lt;/p&gt;


#!/bin/sh

# Usage:    ssh git@host write-git-config &lt;repo&gt; &lt;key&gt; &lt;value&gt;
#
# Set git-config value for user-created (&#34;wild&#34;) repo.

die() { echo &#34;$@&#34; &gt;&amp;2; exit 1; }
usage() { perl -lne &#39;print substr($_, 2) if /^# Usage/../^$/&#39; &lt; $0; exit 1; }
[ -z &#34;$1&#34; ] &amp;&amp; [ -z &#34;$2&#34; ] &amp;&amp; [ -z &#34;$3&#34; ] &amp;&amp; usage
[ &#34;$1&#34; = &#34;-h&#34; ] &amp;&amp; usage
[ -z &#34;$GL_USER&#34; ] &amp;&amp; die GL_USER not set

# ----------------------------------------------------------------------
repo=$1; shift
key=$1; shift
value=$1; shift

# this shell script takes arguments that are completely under the user&#39;s
# control, so make sure you quote those suckers!

if gitolite query-rc -q WRITER_CAN_UPDATE_DESC
then
    gitolite access -q &#34;$repo&#34; $GL_USER W any || die You are not authorised
else
    gitolite creator &#34;$repo&#34; $GL_USER || die You are not authorised
fi

# if it passes, $repo is a valid repo name so it is known to contain only sane
# characters.  This is because &#39;gitolite creator&#39; return true only if there
# *is* a repo of that name and it has a gl-creator file that contains the same
# text as $GL_USER.

configfile=`gitolite query-rc GL_REPO_BASE`/&#34;$repo&#34;.git/config

git config --file &#34;$configfile&#34; &#34;$key&#34; &#34;$value&#34;


&lt;h1 id=&#34;gitolite-hooks&#34;&gt;Gitolite hooks&lt;/h1&gt;

&lt;p&gt;The next step is to write a quick &lt;code&gt;post-receive&lt;/code&gt; hook that check if there is a
certain &lt;code&gt;git-config&lt;/code&gt; entry and run &lt;code&gt;git push --mirror&lt;/code&gt;. The file is in
&lt;code&gt;$HOME/.gitolite/hooks/common/post-receive&lt;/code&gt; ; you could add a better system to
hooks (to be able to add &amp;ldquo;dynamic&amp;rdquo; hooks, …).&lt;/p&gt;


#!/bin/sh

# Simple gitolite mirroring

# flush STDIN coming from git, because gitolite&#39;s own post-receive.mirrorpush
# script does the same thing
[ -t 0 ] || cat &gt;/dev/null

[ -z &#34;$GL_REPO&#34; ] &amp;&amp; die GL_REPO not set

target=`git config --get mirror.url`
[ -z &#34;$target&#34; ] &amp;&amp; exit 0

# Support a REPO variable for wildcard mirrors
gl_repo_escaped=$(echo $GL_REPO | sed &#39;s/\//\\\//g&#39;)
target=$(echo $target | sed -e &#34;s/REPO/$gl_repo_escaped/g&#34;)

# Do the mirror push
git push --mirror $target


&lt;p&gt;The next, and final step is to run &lt;code&gt;gitolite compile&lt;/code&gt; to update links to hooks
for every repositories.&lt;/p&gt;

&lt;h1 id=&#34;for-real&#34;&gt;For real&lt;/h1&gt;

&lt;p&gt;And finaly, this is the final step you&amp;rsquo;ll do.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ssh git@host write-git-config vincent/vcsh-home mirror.url git@github.com:vdemeester/vcsh-home.git
$ git push
Counting objects: 5, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (3/3), 294 bytes, done.
Total 3 (delta 2), reused 0 (delta 0)
remote: To git@github.com:vdemeester/vcsh-home.git
remote:    65681a8..701c990  master -&amp;gt; master
To git@host:vincent/vcsh-home.git
   65681a8..701c990  master -&amp;gt; master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that should be it !&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Update 2012/10/04&lt;/strong&gt; : Moved from gitolite fork to &lt;em&gt;gitolite local code&lt;/em&gt;
repository.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>